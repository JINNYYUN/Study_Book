# 비트연산자(bitwise operator)

비트(bit) 단위로 논리 연산을 할 때 사용하는 연산자로, &(AND) |(OR) ^(XOR) ~(반전) >>(left 쉬프트) <<(right 쉬프트)가 있다.

</br>

## **이항연산자**

- **&(AND 연산자)** : 같은 자릿수의 비트가 모두 1일때 결과로 1을 얻고, 아니면 0 얻는다.

```java
// 0xAC -> 1010 1100
// 0xf0 -> 1111 0000

int result = 0xAC & 0xf0;
System.out.println(result); //10진수 형태로 출력 값 : 160
System.out.printf("0x%x", result); //16진수 형태로 출력

//16진수 결과 값 : 0xa0 (1010 0000)
```

- **| (OR 연산자)** : 같은 자릿수의 비트중에 하나라도 1일 경우 1을 결과로 얻고, 그 외에는 0을 얻는다.

```java
//0xAC -> 0100 1000
//0xf0 -> 1111 0000

result = 0xAC | 0xf0;
System.out.println(result); //10진수 형태로 출력값 : 252
System.out.printf("0x%x", result); 

//16진수 결과 값 : 0xfc (1111 1100)
```

- **^(XOR 연산자)** : 같은 자릿수의 비트가 다를 때만 1을 결과로 얻고, 같을 때는 0을 얻는다.

```java
// 0xc4 -> 1100 0100
// 0x78 -> 0111 1000

result = 0xc4 ^ 0x78;
System.out.println(result); // 10진수 형태의 출력 값 : 188
System.out.printf("0x%x \n", result);\

//16진수 형태의 출력 값 : 0xbc (1011 1100)
```

</br>

## **비트전환연산자**

**~(비트 전환 연산자)** : 2진수로 표현했을 때, 0은 1로, 1은 0으로 전환한다. 논리부정 연산자 ! 와 유사

```java
// 0x55 -> 0101 0101
byte by = ~0x55;

System.out.printf("0x%x \n", by); 
//~0x55  16진수 출력 값 : 0xaa (1010 1010)
```

</br>

## **쉬프트연산자**

피연산자를 2진수로 표현했을 때 각 자리를 오른쪽(>>), 왼쪽(<<)으로 이동(shift)한다.

- **x<<n** : 비트를 왼쪽으로 n번 이동 시킨다. 빈자리는 0으로 채워진다. <<연산자의 경우 부호에 상관없이 각 자리를 왼쪽으로 이동시키며 빈칸을 0으로만 채우면 된다.

```java
		byte by1 = 8; 
        
		by1 <<= 1;
		System.out.println(by1); // 출력값 : 16
		
		by1 <<= 1;
		System.out.println(by1);  // 출력값 : 32
		
		by1 <<= 1;
		System.out.println(by1); // 출력값 : 64
```

2진수 n자리를 왼쪽으로 이동하면(X<<n) 피연산자를 (2^n)한 결과와 같다.

- **x>>n** : 비트를 오른쪽으로 n번 이동 시킨다. 왼쪽의 빈자리의 경우 부호를 유지하기 위해 피연산자가 음수인 경우 빈자리를 1로 채운다. 양수일때는 0으로 채우면 된다.

```java
		byte by1 = 8; 
        
		by1 >>= 1;
		System.out.println(by1); // 출력값 : 4
		
		by1 >>= 1;
		System.out.println(by1);  // 출력값 : 2
		
		by1 >>= 1;
		System.out.println(by1); // 출력값 : 1
```

2진수 n자리를 오른쪽으로 이동하면(x>>n) 피연산자를 (2^n)으로 나눈 결과와 같다.